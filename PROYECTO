/*
 * proyectooo_2.c
 * Universidad del Valle de Guatemala 
 * Programación de Microcontroladores - 10
 * Author : dulce salguero - 231208
 * Descripción: sistema de ojos mecánicos, 6 servos, 1 joystick, 1 pote, 2 botones - Control de PWM, EEPROM
* Hardware:
 *  - 6 servos: PWM por Timers 0,1,2
 *  - Joystick:  X = A6, Y = A7
 *  - Potenciómetro: A0
 *  - Botón  D2  (cambio de modo)
 *  - LED   D13  (indica el modo actual)

* SIRVEN LOS SERVOS --  MODO MANUAL: CHECKKK --- FORMATO DE MODOS: CHECKKK (comienza con modo manual ¡REVISAR LÓGICA DE LED!!))
 */

#define F_CPU 16000000
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

// Definición de modos 
typedef enum {
    MODO_FISICO,
    MODO_EPROM,
    MODO_SERIAL
} ModoOperacion;

volatile ModoOperacion modo_actual = MODO_FISICO; // Inicia en modo físico

// Prototipos
void setup();
void initADC();
uint16_t leerADC(uint8_t canal);
void initPWM();
uint8_t boton_presionado();
void cambiar_modo();

// --- FUNCIONES DE MAPEO ---
void PWM_setAngle(uint16_t angle) {
    OCR1A = angle;
}
void PWM_setAngle2(uint16_t mov) {
    OCR1B = mov;
}
void PWM_setAngle3(uint16_t tung) {
    OCR2A = tung;
}
void PWM_setAngle4(uint16_t cerati) {
    OCR2B = cerati;
}
void PWM_setAngle5(uint16_t angle5) {
    OCR0A = angle5;
}
void PWM_setAngle6(uint16_t angle6) {
    OCR0B = angle6;
}

int main(void) {
    setup();
    initADC();
    initPWM();
    
    while(1) {
        cambiar_modo(); // Control del cambio de modo
        
        switch(modo_actual) {
            case MODO_FISICO: {
        
                uint16_t servo1 = leerADC(6);
                uint16_t angle = (servo1 * -1.96) + 2100.0;
                PWM_setAngle(angle);
                
                uint16_t servo2 = leerADC(6);
                uint16_t mov = (servo2 * 1.96) + 1199.0;
                PWM_setAngle2(mov);
                
                uint16_t lol = leerADC(6);
                uint16_t tung = (lol * 0.0137) + 9;
                PWM_setAngle3(tung);
                
                uint16_t caifanes = leerADC(7);
                uint16_t cerati = (caifanes * 0.00684) + 9;
                PWM_setAngle4(cerati);
                
                uint16_t cejas = leerADC(0);
                uint16_t angle5 = (cejas * 0.0039) + 9;
                PWM_setAngle5(angle5);
                
                uint16_t cejas2 = leerADC(0);
                uint16_t angle6 = (cejas2 * -0.0039) + 13;
                PWM_setAngle6(angle6);
                break;
                
            case MODO_EPROM:
                // (Se implementará después)
                break;
                
            case MODO_SERIAL:
                // (Se implementará después)
                break;
			}
        }
    }
}

// --- FUNCIONES DE CONFIGURACIÓN ---
void setup() {
    // Configuración de botón 
    DDRD &= ~(1 << PIND2);
    PORTD |= (1 << PIND2); // Pull-up
    DDRD &= ~(1 << PIND6);
    PORTD |= (1 << PIND6);
    
    // LEDs para feedback visual
    DDRB |= (1 << PORTB5);
}

void initPWM() {
    // Timer1 (Servos 1 y 2)
    TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
    ICR1 = 20000;
    DDRB |= (1 << PORTB1) | (1 << PORTB2);
    
    // Timer2 (Servos 3 y 4)
    TCCR2A = (1 << COM2A1) | (1 << COM2B1) | (1 << WGM21) | (1 << WGM20);
    TCCR2B = (1 << CS22) | (1 << CS21);
    DDRB |= (1 << PORTB3);
    DDRD |= (1 << PORTD3);
    
    // Timer0 (Servos 5 y 6)
    TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM01) | (1 << WGM00);
    TCCR0B = (1 << CS02) | (1 << CS00);
    DDRD |= (1 << PORTD5) | (1 << PORTD6);
}

// --- FUNCIONES DE CAMBIO DE MODO ---
uint8_t boton_presionado() {
    if (!(PIND & (1 << PIND2))) {
        _delay_ms(20);
        if (!(PIND & (1 << PIND2))) {
            return 1;
        }
    }
    return 0;
}

void cambiar_modo() {
    if (boton_presionado()) {
        while (!(PIND & (1 << PIND2)));
        _delay_ms(20);
        
        modo_actual = (modo_actual + 1) % 3;
        
        // Feedback visual -- LED
        if(modo_actual == MODO_FISICO) {
            PORTB |= (1 << PORTB5); // LED encendido = modo físico
        } else {
            PORTB &= ~(1 << PORTB5);
        }
    }
}

// Función ADC (igual a tu versión)
void initADC() {
    ADMUX = (1 << REFS0);
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
}

uint16_t leerADC(uint8_t canal) {
    ADMUX = (ADMUX & 0xF0) | (canal & 0x0F);
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));
    return ADC;
}
